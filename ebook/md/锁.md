---
title: 锁
---
## 定义

### 管理共享资源并发访问

- 行
- Innodb内部

	- 缓冲池中的LRU删除，添加移动

### 作用

- 支持共享资源并发访问
- 提供数据的完整性和一致性

### MyISAM

- 锁是表设计

	- 读没问题
	- 并发插入慢

### MSServer

- 页设计

	- 性能有所提高
	- 页锁容易实现
	- 页并发无能为力

- 05版本后

	- 支持乐观锁和悲观锁

		- 乐观锁支持行级别锁

	- 锁是一种稀缺资源
	- 锁升级

### Innodb & Oracle

- 一致性非锁定读
- 行级锁支持

	- 没有额外开销，可以得到并发性和一致性

## lock于latch

### latch

- 闩锁，轻量级的锁

	- mutex 互斥量
	- rwlock 读写锁

- 目的

	- 保证并发线程临界资源的正确性，没有死锁的检测机制

### lock

- 对象是事务，锁定数据库中的对象，表、页、行
- 一般仅在事务commit或者rollback后进行释放
- 有死锁机制

### 比较

## Innodb中的锁

### 锁的类型

- 共享锁 S Lock

	- 允许事务读一行数据

- 排他锁 X Lock

	- 允许事务删除或更新一行数据

- 兼容性
- 多粒度锁定

	- 意向锁

- 意向共享锁 IS Lock

	- 事务想要获得一张表中的某几行的共享锁

- 意向排他锁 IX Lock

	- 事务想要获得一张表中的某几行的排他锁

- 兼容性

	- Innodb存储引擎支持的是行级别的锁，不会阻塞除全表扫描以外的任何请求
	- 

- 命令

	- show full  processlist
	- show engine innodb status
	- innodb_trx

		- 表示当前运行的事务

	- innodb_locks

		- 表示所有锁的信息

	- innodb_lock_waits

		- 表示阻塞关系

### 一致性非锁定读

- 通过多版本控制MVCC读取当前执行时间数据库中的行数据
- 通过undo段来完成

	- read committed

		- 快照的最新一份数据

			- 读取提交后的数据

	- repeatable read

		- 事务开始时的数据版本

			- 读取开始时的数据

	- 

### 一致性锁定读

- select for update

	- 对行加X锁

		- 对于一致性非锁定读，仍然可以读

- select lock in share mode

	- 对行加S锁

- 以上两种必须声明在事务中

### 自增长与锁

- 自增长

	- anto-inc locking

		- 特殊的表锁机制，不是在事务完成时释放，而是完成对自增长值插入后立即释放

	- 存在性能问题

		- 并发性能较差，事务必须等待前一个插入完成，虽然不用等待整个事务完成
		- 对于insert select 大数据量的插入会影响插入性能，因为另一个事务中的插入会阻塞

	- 5.1.22版本后

		- 轻量级互斥量自增长
		- innodb_autoinc_lock_mode默认值1
		- 插入类型

			- 

		- 参数说明

			- 

	- 自增长必须是索引列，同时必须是索引的第一列
	- MyISAM 没有并发自增长问题，表锁设计，不需要一定是索引列

### 外键和锁

- Innodb自动对外键加索引

	- 外键阻塞

## 锁的算法

### 行锁的三种算法

- Record Lock

	- 单行记录上的锁

		- 锁住索引记录

- Gap Lock

	- 间隙锁，锁定一个范围，不包含记录本身

- Next-Key Lock

	- Recored Lock+Gap Lock

		- Innodb对于行的查询都是采用这种算法
		- 当查询的索引是唯一索引（聚集索引）时，被优化，降级为Recored Lock
		- 辅助索引锁定的是范围，并且还会对下一个键值加gap lock
		- 作用 避免幻读
		- 关闭方式

			- 事务的隔离级别设置为READ COMMITED
			- innodb_locks_unsafe_for_binlog 设置为1

### 解决Phantom Problem

- 定义

	- 在同一事务下，连续执行两次同样的sql语句可能导致不同的结果

- 解决

	- 加S Lock，锁定的为范围

## 锁问题

### 脏读

- read uncommited发生
- 定义

	- 读到了其他事务未提交的数据

### 不可重复读

- 指在一个事务内多次读取同一数据集结果不一致
- read committed发生
- oracle mss默认设置
- Innodb通过next-key locking算法避免不可重复读

	- 对于索引的扫描，不仅是锁住扫描到的索引，而且还锁住这些索引覆盖的范围，因此在这个范围内的插入都是不允许的

- Innodb存储引擎默认 repeatable

### 丢失更新

- 定义：一个事务的更新操作被另一个事务的更新操作覆盖，导致数据不一致
- 解决：对用户读取的记录添加排他X锁

## 阻塞

### 定义：一个事务中的锁需要等待另一个事务中的锁释放占用资源

### innodb_lock_wait_timeout 控制等待的时间，动态的

### innodb_rollback_on_timeout 控制等待超时是否回滚，静态的

### Innodb不会回滚超时引发错误，且大部分情况下对异常不会回滚

## 死锁

### 概念

- 两个或者两个以上事务在执行时，因争夺锁资源而造成的等待的现象
- 超时时回滚

	- FIFO顺序回滚

- 死锁检测

	- wait-for gragh 等待图

		- 锁的信息链表
		- 等待事务链表

	- 事务请求锁并发等待时判断是否存在回路，若存在，Innodb选择回滚undo量最小的事务
	- 深度优先算法

### 概率

- 事务的数量越多，概率越大
- 每个事务操作的数量越多，概率越大
- 操作数据的集合越小，概率越大

### 示例

- AB-BA死锁

	- Innodb不会回滚大部分异常，但是会回滚死锁

- 事务持有待插入记录的下一个记录的X锁，但是等待队列中存在一个S锁

	- 这个问题的产生是由于会话B中请求记录4的S锁而发生等待，但之前请求的锁对于主键值记录1、2都已经成功，若在事件点5能插入记录，那么会话B在获得记录4持有的S锁后，还需要向后获得记录3的记录，这样就显得有点不合理。因此InnoDB存储引擎在这里主动选择了死锁，而回滚的是undo log记录大的事务，这与AB-BA死锁的处理方式又有所不同。

## 锁升级

### 概念

- 将锁粒度降低

	- 行级升级为页级，页级升级为表级

### Innodb不存在锁升级问题

- 不是行锁
- 事务访问的页对锁管理
- 位图的方式

