---
title: 并发机制底层
---


## CPU术语

### 内存屏障

- 处理器指令，用于实现对内存操作的顺序限制

### 缓冲行

- 缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行，需要使用多个主内存周期

### 原子操作

- 不可中断的一个或一些列操作

### 缓存行填充

- 当处理器识别到从内存中读取操作数是可以缓存的，处理器读取整个缓存到适当的缓存（L1,L2,L3或所有）

### 缓存命中

- 如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取

### 写命中

- 当处理器将操作数写回到一个内存缓存区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存。

### 写缺失

- 一个有效的缓存行被写入到不存在的内存区域

## volatile的应用

### 实现原理

- Lock指令

	- 将当前处理器缓存行的数据写回到系统内存
	- 写回操作使在其他cpu里缓存的该内存地址的数据无效

### 使用优化

- LinkedTransferQueue

	- PaddedAtomicReference
	- 使用追加到 64 字节的方式来填满高 速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时 不会互相锁定。

## synchronize的实现原理

### 实现基础

- 实现形式

	- 对于普通同步方法，锁是当前实例对象
	- 对于静态同步方法，锁是当前类的 Class 对象
	- 对于同步方法块，锁是 Synchonized 括号里配置的对象

- 实现原理

	- JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步

		- 代码块同步是使 用 monitorenter 和 monitorexit 指令实现的
		- 方法同步是使用另外一种方式实现
		- monitorenter编译后插入到同步代码块的开始位置
		- monitorexit插入到 方法结束处和异常处
		- 每个 monitorenter 必须有对应的 monitorexit 与之配 对
		- 任何对象都有一个 monitor 与之关联，当且一个 monitor 被持有后，它将处于锁定状 态
		- 程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即 尝试获得对象的锁

### java对象头

- synchronized用的锁是存在java对象头里的

	- 数组三个字宽
	- 非数组两个字宽
	- 组成

		- Mark Word 存储对象的hashcode或者锁信息
		- calss metadata address 存储对象类型数据的指针
		- array length 数组的长度

- Mark Word的组成

	- 32位

		- 无锁状态

			- 25bit

				- 对象的hashcode

			- 4bit

				- 对象分代年龄

			- 1bit是否是偏向锁

				- 0

			- 2bit锁标志位

				- 01

		- 轻量级锁

			- 25+4+1 bit

				- 指向栈中锁记录的指针

			- 2bit 锁标志位

				- 00

		- 重量级锁

			- 25+4+1 bit

				- 指向互斥量（重量级锁）的指针

			- 2bit 锁标志位

				- 10

		- GC标记

			- 25+4+1 bit

				- 空

			- 2bit 锁标志位

				- 11

		- 偏向锁

			- 25+4 bit

				- 23 bit

					- 线程ID

				- 2bit +4 bit

					- Epoch
					- 对象分代年龄

			- 1 bit 是否偏向锁

				- 1

			- 2bit 锁标志位

				- 01

	- 64位

		- 无锁

			- 25bit

				- unused

			- 31bit

				- hashcode

			- 1bit
			- 4bit
			- 1bit

				- 0

			- 2bit

				- 01

		- 偏向锁

			- 25+31bit

				- ThreadID(54bit)Epoch(2bit)

			- 1bit
			- 4bit
			- 1bit

				- 1

			- 2bit

				- 01

### 锁的升级

- 偏向锁

	- 流程![偏向锁](https://happyguozf.github.io/picgoimages//img/%E5%81%8F%E5%90%91%E9%94%81.png)
	- 偏向锁使用了一种等到竞争出现才释放锁的机制

- 轻量级锁

	- 流程![轻量级锁](https://happyguozf.github.io/picgoimages//img/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png)

### 锁的对比

- 优点

	- 偏向锁

		- 加锁和解锁不需要额外的消耗，和执行非同步方法比较仅存在纳秒级差距

	- 轻量级锁

		- 竞争的线程不会阻塞，提高了程序的响应速度

	- 重量级锁

		- 线程竞争不实用自旋，不会消耗cpu

- 缺点

	- 偏向锁

		- 如果线程间存在锁竞争，会带来额外的锁撤销的消耗

	- 轻量级锁

		- 如果始终得不到锁竞争的线程，使用自旋会消耗cpu

	- 重量级锁

		- 线程阻塞，响应时间缓慢

- 适用场景

	- 偏向锁

		- 适用只有一个线程访问同步块场景

	- 轻量级锁

		- 追求响应时间，同步块执行非常快

	- 重量级锁

		- 追求吞吐量，同步块执行时间较长

## 原子操作的实现原理

### 定义

- 缓存行

	- 缓存的最小操作单位

- 比较并交换

	- cas操作需要输入两个数值，一个旧值和一个新值，在操作期间先比较旧值有没有变化，如果没有发生变化，才交换成新值，发生了变化则不交换

- cpu流水线

	- cpu流水线的工作方式就像工业生产上的装配流水线，在cpu中由5-6个不同功能的电路单元组成一条指令流水线，然后将一条X86指令分成5-6步后再由这些电路单元分别执行，这样就能实现在一个cpu时钟周期内完成一条指令，因此提高cpu的运算速度。

- 内存顺序冲突

	- 内存顺序冲突一般是由假共享引起的，假共享是指多个cpu同时修改同一个缓存行的不同部分而引起其中一个cpu的操作无效，当出现这个内存顺序冲突时，cpu必须清空流水线

### 处理器实现

- 总线锁

	- 总线锁就是使用处理器提供的一个 LOCK# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处 理器可以独占共享内存

- 缓存锁

	- 所谓“缓存锁定”是指内存区域如果被缓 存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当它执行锁操作回写到内存 时，处理器不在总线上声言 LOCK#信号，而是修改内部的内存地址，并允许它的缓存 一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理 器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无 效
	- 不使用缓存锁定

		- 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存 行(cache line)时，则处理器会调用总线锁定
		- 有些处理器不支持缓存锁定

- Lock前缀

	- 位测试和修改指令:BTS、BTR、BTC
	- 交换指令 XADD、CMPXCHG
	- 其他 一些操作数和逻辑指令ADD、OR

### java实现原子操作

- 使用循环 CAS 实现原子操作

	- 处理器提供的 CMPXCHG 指令实现
	- 自旋 CAS 实 现的基本思路就是循环进行 CAS 操作直到成功为止
	- 三大问题

		- ABA 问题

			- ABA 问题的解决思路就是使 用版本号
			- 类 AtomicStampedReference 来解决 ABA 问题

		- 循环时间长开销大

			- pause 指令

				- 它可以延迟流水线执行指令(de-pipeline)，使 CPU 不会消耗过多的 执行资源
				- 它可以避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起 CPU 流 水线被清空(CPU Pipeline Flush)，从而提高 CPU 的执行效率

		- 只能保证一个共享变量的原子操作

			- 把多个共享变量合并 成一个共享变量来操作。比如，有两个共享变量 i=2，j=a，合并一下 ij=2a，然后用 CAS 来操作 ij
			-  AtomicReference 类来保证引用对象之间的 原子性，就可以把多个变量放在一个对象里来进行 CAS 操作

- 使用锁机制实现原子操作

	- 偏向锁、轻量级锁和互斥锁
	- 除了偏向锁，JVM 实现锁的方式 都用了循环 CAS，即当一个线程想进入同步块的时候使用循环 CAS 的方式来获取锁， 当它退出同步块的时候使用循环 CAS 释放锁

